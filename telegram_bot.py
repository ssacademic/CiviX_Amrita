# -*- coding: utf-8 -*-
"""telegram_bot

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rHH_VG5nU4tjOuF5Y5-AXELjCbpxPU_9
"""

# ============================================================
# TELEGRAM BOT FOR HONEYPOT TESTING
# Complete testing interface via Telegram
# ============================================================

import os
import time
import json
import requests
from datetime import datetime
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    Application,
    CommandHandler,
    MessageHandler,
    CallbackQueryHandler,
    ContextTypes,
    filters
)

# ============================================================
# CONFIGURATION
# ============================================================

TELEGRAM_BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN", "8523787874:AAGAEZbX6w--7WKA8wJRm5OEjvYjyoeWKUA")
HONEYPOT_API_URL = os.getenv("HONEYPOT_API_URL", "https://guvi-honeypot-zdg5.onrender.com")
API_SECRET_KEY = os.getenv("API_SECRET_KEY", "honeypot_secret_2026")

# Store user sessions
user_sessions = {}

# ============================================================
# SCAM TEMPLATES
# ============================================================

SCAM_TEMPLATES = {
    "1": {
        "name": "üè¶ Account Block",
        "message": "Dear customer, your HDFC Bank account will be blocked in 2 hours due to KYC non-compliance. Call immediately at 9876543210 or email urgent@fakehdfc.com to verify your account."
    },
    "2": {
        "name": "üí≥ UPI Fraud",
        "message": "Your Paytm account has suspicious activity. UPI ID will be blocked. Update KYC at bit.ly/paytm-verify or contact support@paytm"
    },
    "3": {
        "name": "üéÅ Prize Scam",
        "message": "Congratulations! You won Rs 10,00,000 in KBC lucky draw. Contact manager Mr. Sharma at 9123456780 or email prize@kbc-lottery.com to claim your prize."
    },
    "4": {
        "name": "üõ°Ô∏è Card Block",
        "message": "URGENT: Your SBI Debit Card has been blocked due to failed transaction. Verify your details immediately at sbi-secure-login.com or call helpline 8765432109."
    },
    "5": {
        "name": "üí∞ Tax Notice",
        "message": "Income Tax Department: Outstanding dues of Rs 45,000. Pay immediately to avoid legal action. UPI: incometax@okaxis or call 9988776655. Visit: incometax-payment.in"
    },
    "6": {
        "name": "üì¶ Delivery Scam",
        "message": "Your Amazon package is pending. Custom duty Rs 500 required. Pay via GPay to delivery@amazonlogistics or call 9876501234. Track: amzn.to/fake123"
    }
}

# ============================================================
# HELPER FUNCTIONS
# ============================================================

def get_user_session(user_id):
    """Get or create user session"""
    if user_id not in user_sessions:
        user_sessions[user_id] = {
            "session_id": f"telegram_{user_id}_{int(time.time())}",
            "messages": [],
            "turn_count": 0,
            "total_entities": 0,
            "started_at": datetime.now().isoformat()
        }
    return user_sessions[user_id]

def reset_user_session(user_id):
    """Reset user session"""
    if user_id in user_sessions:
        del user_sessions[user_id]
    return get_user_session(user_id)

async def call_honeypot_api(session_id, scam_message, conversation_history):
    """Call honeypot API"""
    try:
        payload = {
            "sessionId": session_id,
            "message": {
                "sender": "scammer",
                "text": scam_message,
                "timestamp": int(time.time() * 1000)
            },
            "conversationHistory": conversation_history,
            "metadata": {
                "channel": "Telegram",
                "language": "English",
                "locale": "IN"
            }
        }

        headers = {
            "x-api-key": API_SECRET_KEY,
            "Content-Type": "application/json"
        }

        response = requests.post(
            f"{HONEYPOT_API_URL}/honeypot",
            json=payload,
            headers=headers,
            timeout=30
        )

        if response.status_code == 200:
            return response.json(), None
        else:
            return None, f"API Error: {response.status_code}"

    except Exception as e:
        return None, f"Connection error: {str(e)}"

async def get_session_entities(session_id):
    """Get extracted entities for session"""
    try:
        headers = {"x-api-key": API_SECRET_KEY}
        response = requests.get(
            f"{HONEYPOT_API_URL}/session/{session_id}/entities",
            headers=headers,
            timeout=10
        )

        if response.status_code == 200:
            return response.json().get('extractedEntities', {})
        return {}
    except:
        return {}

# ============================================================
# COMMAND HANDLERS
# ============================================================

async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle /start command"""
    user_id = update.effective_user.id
    username = update.effective_user.first_name

    welcome_text = f"""
üçØ **Honeypot Testing Bot**

Welcome {username}!

This bot lets you test the Honeypot Scam Detection system by pretending to be a scammer.

**Commands:**
/start - Show this message
/new - Start new test session
/templates - Show scam templates
/stats - View extraction statistics
/help - Get help

**How to use:**
1. Use /new to start a session
2. Send a scam message (or use /templates)
3. See how the honeypot responds
4. Check /stats to see extracted entities

Ready to test? Send /new to begin! üöÄ
    """

    await update.message.reply_text(welcome_text, parse_mode='Markdown')

async def new_session_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Start new testing session"""
    user_id = update.effective_user.id
    session = reset_user_session(user_id)

    await update.message.reply_text(
        f"‚úÖ **New Session Started**\n\n"
        f"Session ID: `{session['session_id'][-12:]}`\n\n"
        f"You can now:\n"
        f"‚Ä¢ Send a custom scam message\n"
        f"‚Ä¢ Use /templates for quick scams\n"
        f"‚Ä¢ Check /stats anytime\n\n"
        f"üé≠ Act like a scammer!",
        parse_mode='Markdown'
    )

async def templates_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Show scam templates"""
    keyboard = []

    for key, template in SCAM_TEMPLATES.items():
        keyboard.append([
            InlineKeyboardButton(
                template['name'],
                callback_data=f"template_{key}"
            )
        ])

    reply_markup = InlineKeyboardMarkup(keyboard)

    await update.message.reply_text(
        "üé≠ **Select a scam template:**\n\n"
        "These are realistic scam messages for testing.",
        reply_markup=reply_markup,
        parse_mode='Markdown'
    )

async def stats_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Show session statistics"""
    user_id = update.effective_user.id

    if user_id not in user_sessions:
        await update.message.reply_text(
            "‚ö†Ô∏è No active session. Use /new to start!"
        )
        return

    session = user_sessions[user_id]

    # Get entities
    entities = await get_session_entities(session['session_id'])

    stats_text = f"""
üìä **Session Statistics**

**Session:** `{session['session_id'][-12:]}`
**Started:** {session['started_at'][:19]}
**Turns:** {session['turn_count']}
**Messages:** {len(session['messages'])}

**üéØ Extracted Entities:**
üìû Phone Numbers: {len(entities.get('phoneNumbers', []))}
üìß Emails: {len(entities.get('emails', []))}
üí≥ UPI IDs: {len(entities.get('upiIds', []))}
üîó Phishing Links: {len(entities.get('phishingLinks', []))}

**Total:** {len(entities.get('phoneNumbers', [])) + len(entities.get('emails', [])) + len(entities.get('upiIds', [])) + len(entities.get('phishingLinks', []))} entities
    """

    await update.message.reply_text(stats_text, parse_mode='Markdown')

    # Show actual extracted items
    if entities.get('phoneNumbers'):
        phones = '\n'.join([f"‚Ä¢ `{p}`" for p in entities['phoneNumbers']])
        await update.message.reply_text(
            f"üìû **Phone Numbers:**\n{phones}",
            parse_mode='Markdown'
        )

    if entities.get('emails'):
        emails = '\n'.join([f"‚Ä¢ `{e}`" for e in entities['emails']])
        await update.message.reply_text(
            f"üìß **Emails:**\n{emails}",
            parse_mode='Markdown'
        )

    if entities.get('upiIds'):
        upis = '\n'.join([f"‚Ä¢ `{u}`" for u in entities['upiIds']])
        await update.message.reply_text(
            f"üí≥ **UPI IDs:**\n{upis}",
            parse_mode='Markdown'
        )

async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Show help"""
    help_text = """
üçØ **Honeypot Testing Help**

**What is this?**
This bot helps test the GUVI Hackathon Honeypot system. You pretend to be a scammer, and the AI agent (honeypot) responds naturally while extracting intelligence.

**How to test:**

1Ô∏è‚É£ **Start Session**
   `/new` - Begin new test

2Ô∏è‚É£ **Send Scam Message**
   Either:
   ‚Ä¢ Type your own scam message
   ‚Ä¢ Use `/templates` for pre-made scams

3Ô∏è‚É£ **View Results**
   `/stats` - See extracted entities

4Ô∏è‚É£ **Reset**
   `/new` - Start fresh session

**Testing Tips:**
‚Ä¢ Include phone numbers, emails, UPI IDs
‚Ä¢ Use urgency and threats (realistic scams)
‚Ä¢ Test multiple turns
‚Ä¢ Check stats after each message

**Example Scam:**
"Your account will be blocked! Call 9876543210 now or email urgent@bank.com"

**For Judges:**
This demonstrates real-time scam detection and intelligence extraction working in production.
    """

    await update.message.reply_text(help_text, parse_mode='Markdown')

# ============================================================
# MESSAGE HANDLERS
# ============================================================

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle incoming scam messages"""
    user_id = update.effective_user.id
    scam_message = update.message.text

    # Check if session exists
    if user_id not in user_sessions:
        await update.message.reply_text(
            "‚ö†Ô∏è No active session. Use /new to start a test session first!"
        )
        return

    session = user_sessions[user_id]

    # Show typing indicator
    await update.message.chat.send_action("typing")

    # Build conversation history
    conversation_history = []
    for msg in session['messages']:
        conversation_history.append({
            "sender": msg['sender'],
            "text": msg['text'],
            "timestamp": int(time.time() * 1000)
        })

    # Call honeypot API
    result, error = await call_honeypot_api(
        session['session_id'],
        scam_message,
        conversation_history
    )

    if error:
        await update.message.reply_text(f"‚ùå Error: {error}")
        return

    if result and result.get('status') == 'success':
        honeypot_reply = result.get('reply', 'No response')

        # Update session
        session['turn_count'] += 1
        session['messages'].append({
            'sender': 'scammer',
            'text': scam_message,
            'timestamp': datetime.now().isoformat()
        })
        session['messages'].append({
            'sender': 'user',
            'text': honeypot_reply,
            'timestamp': datetime.now().isoformat()
        })

        # Send response
        await update.message.reply_text(
            f"üçØ **Honeypot Response:**\n\n{honeypot_reply}\n\n"
            f"_Turn {session['turn_count']} ‚Ä¢ Use /stats for extraction data_",
            parse_mode='Markdown'
        )

        # Auto-show stats every 3 turns
        if session['turn_count'] % 3 == 0:
            entities = await get_session_entities(session['session_id'])
            total = (len(entities.get('phoneNumbers', [])) +
                    len(entities.get('emails', [])) +
                    len(entities.get('upiIds', [])) +
                    len(entities.get('phishingLinks', [])))

            if total > 0:
                await update.message.reply_text(
                    f"üìä **Extracted so far:** {total} entities\n"
                    f"Use /stats to see details",
                    parse_mode='Markdown'
                )
    else:
        await update.message.reply_text("‚ùå Unexpected API response")

async def handle_template_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle template button clicks"""
    query = update.callback_query
    await query.answer()

    template_key = query.data.replace("template_", "")
    template = SCAM_TEMPLATES.get(template_key)

    if not template:
        await query.edit_message_text("‚ùå Template not found")
        return

    user_id = update.effective_user.id

    # Ensure session exists
    if user_id not in user_sessions:
        reset_user_session(user_id)

    await query.edit_message_text(
        f"‚úÖ **Selected:** {template['name']}\n\n"
        f"Sending to honeypot...",
        parse_mode='Markdown'
    )

    # Simulate message with template
    session = user_sessions[user_id]
    scam_message = template['message']

    # Build conversation history
    conversation_history = []
    for msg in session['messages']:
        conversation_history.append({
            "sender": msg['sender'],
            "text": msg['text'],
            "timestamp": int(time.time() * 1000)
        })

    # Call honeypot API
    result, error = await call_honeypot_api(
        session['session_id'],
        scam_message,
        conversation_history
    )

    if error:
        await query.message.reply_text(f"‚ùå Error: {error}")
        return

    if result and result.get('status') == 'success':
        honeypot_reply = result.get('reply', 'No response')

        # Update session
        session['turn_count'] += 1
        session['messages'].append({
            'sender': 'scammer',
            'text': scam_message,
            'timestamp': datetime.now().isoformat()
        })
        session['messages'].append({
            'sender': 'user',
            'text': honeypot_reply,
            'timestamp': datetime.now().isoformat()
        })

        # Send scammer message
        await query.message.reply_text(
            f"ü¶π **You (Scammer):**\n{scam_message}",
            parse_mode='Markdown'
        )

        # Send honeypot response
        await query.message.reply_text(
            f"üçØ **Honeypot Response:**\n\n{honeypot_reply}\n\n"
            f"_Turn {session['turn_count']} ‚Ä¢ Use /stats for extraction data_",
            parse_mode='Markdown'
        )

# ============================================================
# MAIN APPLICATION
# ============================================================

def main():
    """Start the bot"""
    print("="*60)
    print("üçØ HONEYPOT TELEGRAM BOT STARTING...")
    print("="*60)
    print(f"API URL: {HONEYPOT_API_URL}")
    print(f"Bot Token: {TELEGRAM_BOT_TOKEN[:20]}...")
    print("="*60)

    # Create application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()

    # Add command handlers
    application.add_handler(CommandHandler("start", start_command))
    application.add_handler(CommandHandler("new", new_session_command))
    application.add_handler(CommandHandler("templates", templates_command))
    application.add_handler(CommandHandler("stats", stats_command))
    application.add_handler(CommandHandler("help", help_command))

    # Add message handler
    application.add_handler(MessageHandler(
        filters.TEXT & ~filters.COMMAND,
        handle_message
    ))

    # Add callback handler for template buttons
    application.add_handler(CallbackQueryHandler(handle_template_callback))

    # Start bot
    print("‚úÖ Bot is running! Send /start to your bot on Telegram")
    print("="*60)

    application.run_polling(allowed_updates=Update.ALL_TYPES)

if __name__ == '__main__':
    main()